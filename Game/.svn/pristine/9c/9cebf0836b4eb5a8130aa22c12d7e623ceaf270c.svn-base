#include "PlayState.h"

PlayState::PlayState(int STATE_ID, sf::RenderWindow* window, sf::RenderTexture* renderTexture) :
State(STATE_ID, window, renderTexture)
{
}

PlayState::~PlayState()
{//Deleting class pointers
	deinit();
}

bool PlayState::init()
{
	if (!tmxMap_.loadMap("res//map.tmx"))
		return(false);

	if (!texture_.loadFromFile("res//entities//entity.png"))
		return(false);

	tiledMap_.setTMXFile(&tmxMap_);
	tiledMap_.initaliseMap();


	player_.setScale(32.f, 32.f);
	player_.setPosition(5 * 64, 5 * 64);
	player_.setOrigin(0.5f, 0.5f);
	player_.setTexture(&texture_);

	player_.setVertexTextureCoords(0, sf::Vector2f(0.f, 0.f));
	player_.setVertexTextureCoords(1, sf::Vector2f(128.f, 0.f));
	player_.setVertexTextureCoords(2, sf::Vector2f(128.f, 128.f));
	player_.setVertexTextureCoords(3, sf::Vector2f(0.f, 128.f));

	const float SIZE(1.5f);

	player_.xCollider.width = player_.getGlobalBounds().width * SIZE;
	player_.xCollider.height = player_.getGlobalBounds().height * SIZE;

	player_.yCollider.width = player_.getGlobalBounds().width * SIZE;
	player_.yCollider.height = player_.getGlobalBounds().height * SIZE;

	camera_ = new Camera(sf::Vector2u(tmxMap_.getLayer()[0]->width, tmxMap_.getLayer()[0]->width), renderTexture_);
	sf::View v(renderTexture_->getView());
	v.setCenter(tmxMap_.getWidth() * tmxMap_.getTileWidth(), tmxMap_.getHeight() * tmxMap_.getTileHeight());
	v.zoom(0.75f);
	renderTexture_->setView(v);

	{//Loading lights & shaders
		//Load the lightmask texture
		if (!lightTexture_.loadFromFile("res//shaders//lightmask.png"))
			return(false);

		//Create a RenderTexture to draw the lights onto
		if (!lightRenderTxt_.create(renderTexture_->getSize().x, renderTexture_->getSize().y))
			return(false);

		if (!sceneRender_.create(tmxMap_.getTileWidth() * tmxMap_.getWidth(), tmxMap_.getTileHeight() * tmxMap_.getHeight()))
			return(false);

		//Initialising the light RectangleShape
		light_.setTexture(&lightTexture_);
		light_.setSize(sf::Vector2f(static_cast<float>(lightTexture_.getSize().x), static_cast<float>(lightTexture_.getSize().y)));
		light_.setScale(1.5f, 1.5f);

		if (!shader_.loadFromFile("res///shaders//vertexShader.vert", "res//shaders//fragmentShader.frag"))
			return(false);


		//Set the renderstates to use the correct shader & blend mode
		shaderState_.shader = &shader_;
		shaderState_.blendMode = sf::BlendAlpha;
	}

	xCol.setSize(sf::Vector2f(60.f, 60.f));
	yCol.setSize(sf::Vector2f(60.f, 60.f));
	xCol.setFillColor(sf::Color::Red);
	yCol.setFillColor(sf::Color::Blue);
	xCol.setPosition(player_.getPosition());
	yCol.setPosition(player_.getPosition());
	col = &xCol;
	id = 0;
	return(true);
}

void PlayState::render()
{

	renderTexture_->draw(tiledMap_);
	renderTexture_->draw(player_);

	renderTexture_->draw(player_.getSprintRect());

	lightRenderTxt_.clear();
	lightRenderTxt_.setView(renderTexture_->getView());
	lightRenderTxt_.draw(light_, sf::BlendAdd);
	lightRenderTxt_.display();

	shader_.setParameter("lightMapTexture", lightRenderTxt_.getTexture());
	shader_.setParameter("resolution", static_cast<float> (renderTexture_->getSize().x), static_cast<float> (renderTexture_->getSize().y));

	shader_.setParameter("ambientColour", 0.27f, 0.15f, 0.3f, 1.6f);

	sceneRender_.clear();
	sceneRender_.draw(tiledMap_);
	//sceneRender_.draw(*col);
	player_.setOrigin(0.5, 0.5f);
	sceneRender_.draw(player_);
	player_.setOrigin(0.f, 0.f);
	sceneRender_.draw(player_.getSprintRect());
	sceneRender_.display();

	sf::Sprite s(sceneRender_.getTexture());
	renderTexture_->draw(s, shaderState_);
	renderTexture_->display();
}

void PlayState::update(const sf::Time& delta)
{
	sf::Vector2i mousePos = sf::Mouse::getPosition(*window_);
	sf::Vector2f worldPos = renderTexture_->mapPixelToCoords(mousePos);
	sf::Vector2f playerCentrePos(player_.getPosition().x + player_.getGlobalBounds().width / 2, player_.getPosition().y + player_.getGlobalBounds().height / 2);
	sf::Vector2f rot(worldPos.x - player_.getPosition().x, worldPos.y - player_.getPosition().y);

	float rotation = (degrees(atan2(rot.y, rot.x))); //+ 90;
	player_.setRotation(rotation);
	updateMovement(delta);
	player_.updateSprintBar();

	camera_->update(delta, player_.getPosition(), true);
}

void PlayState::updateMovement(const sf::Time& delta)
{
	sf::Vector2f movement;
	sf::Vector2f direction(0, 0);
	sf::Vector2f colMove;
	const float SIZE(1.5f);


	player_.xCollider.top = player_.getPosition().y - player_.xCollider.height / 2.f;
	player_.xCollider.left = player_.getPosition().x - player_.xCollider.width / 2.f;

	player_.yCollider.top = player_.getPosition().y - player_.yCollider.height / 2.f;
	player_.yCollider.left = player_.getPosition().x - player_.yCollider.width / 2.f;

	xCol.setPosition(player_.xCollider.left, player_.xCollider.top);
	xCol.setSize(sf::Vector2f(player_.xCollider.width, player_.xCollider.height));
	yCol.setPosition(sf::Vector2f(player_.yCollider.left, player_.yCollider.top));
	yCol.setSize(sf::Vector2f(player_.yCollider.width, player_.yCollider.height));

	light_.setPosition(player_.getPosition().x + (player_.getGlobalBounds().width / 2) - (light_.getGlobalBounds().width / 2.f), player_.getPosition().y + (player_.getGlobalBounds().width / 2) - light_.getGlobalBounds().height / 2.f);

	if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift))	//press shift and sprint 
	{
		player_.sprint();
	}
	else //otherwise walk
	{
		player_.walk();
	}


	if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) || sf::Keyboard::isKeyPressed(sf::Keyboard::Left) || sf::Keyboard::isKeyPressed(sf::Keyboard::Up) || sf::Keyboard::isKeyPressed(sf::Keyboard::Down)
		|| sf::Keyboard::isKeyPressed(sf::Keyboard::A) || sf::Keyboard::isKeyPressed(sf::Keyboard::D) || sf::Keyboard::isKeyPressed(sf::Keyboard::W) || sf::Keyboard::isKeyPressed(sf::Keyboard::S))
	{ //if a directional key is pressed

		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) || sf::Keyboard::isKeyPressed(sf::Keyboard::W))
		{//if up key is pressed change direction y vector to -1 and move the y collider above the player
			direction.y = -1;
			player_.yCollider.top -= (player_.getMoveSpeed() * delta.asSeconds());
			yCol.setPosition(player_.yCollider.left, player_.yCollider.top);
		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) || sf::Keyboard::isKeyPressed(sf::Keyboard::S))
		{//if down key is pressed change direction y vector to 1 and move the y collider below the player
			direction.y = 1;
			player_.yCollider.top += (player_.getMoveSpeed() * delta.asSeconds());
			yCol.setPosition(player_.yCollider.left, player_.yCollider.top);

		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) || sf::Keyboard::isKeyPressed(sf::Keyboard::A))
		{//if left key is pressed change direction x vector to -1 and move the x collider left of the player
			direction.x = -1;
			player_.xCollider.left -= (player_.getMoveSpeed() * delta.asSeconds());
			xCol.setPosition(player_.xCollider.left, player_.xCollider.top);

		}
		if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) || sf::Keyboard::isKeyPressed(sf::Keyboard::D))
		{//if left key is pressed change direction x vector to 1 and move the x collider right of the player
			direction.x = 1;
			player_.xCollider.left += (player_.getMoveSpeed() * delta.asSeconds());
			xCol.setPosition(player_.xCollider.left, player_.xCollider.top);

		}

		//create a vector that uses the two colliders and the direction to work out collisions
		colMove = sf::Vector2f(tiledMap_.collider(player_.xCollider, player_.yCollider, direction));

		if (colMove.y == 0) // if there is no collision move in desired direction
		{
			movement.y = direction.y;
		}

		if (colMove.x == 0)  // if there is no collision move in desired direction
		{
			movement.x = direction.x;
		}


		if (movement.x != 0 && movement.y != 0) //if the movement vector is not (0,0)
		{

			movement = sf::Vector2f(normalize(movement)); //normalize the movement vector so diagnal movement isn't quicker
		}
		movement.x *= player_.getMoveSpeed() * delta.asSeconds();	//times the movement vector by moveSpeed and delta
		movement.y *= player_.getMoveSpeed() * delta.asSeconds();
		player_.move(movement);	//move the player
	}

	bool moving(movement.x != 0.f || movement.y != 0.f);
}

void PlayState::handleEvents(sf::Event& evnt, const sf::Time& delta)
{
	if (evnt.type == sf::Event::KeyPressed)
	{
		if (evnt.key.code == sf::Keyboard::Z)
		{//Remove after completion
			switch (id)
			{
			case 0:
				col = &yCol;
				id = 1;
				break;
			case 1:
				col = &xCol;
				id = 0;
				break;
			}
		}



	}
}

void PlayState::deinit()
{
	delete camera_;
}